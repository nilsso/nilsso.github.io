var e=Object.defineProperty,t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,o=(t,n,a)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[n]=a,r=(e,r)=>{for(var l in r||(r={}))n.call(r,l)&&o(e,l,r[l]);if(t)for(var l of t(r))a.call(r,l)&&o(e,l,r[l]);return e};import{R as l,r as i,c as s,a as d,m as c,b as u,w as h,o as p,d as m,e as f,T as b,f as g,K as v,g as y,s as w,h as x,i as S,j as k,k as P,l as j,n as A}from"./vendor.c3ad2312.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const n of e)if("childList"===n.type)for(const e of n.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerpolicy&&(t.referrerPolicy=e.referrerpolicy),"use-credentials"===e.crossorigin?t.credentials="include":"anonymous"===e.crossorigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();const M={name:"AppLink",inheritAttrs:!1,props:r({},l.props),computed:{isExternalLink(){return"string"==typeof this.to&&this.to.startsWith("http")}}},I=["href"],_=["href","onClick"];M.render=function(e,t,n,a,o,r){const l=i("router-link");return r.isExternalLink?(p(),s("a",c({key:0},e.$attrs,{href:e.to,target:"_blank",class:"btn-inv text-xl"}),[d(e.$slots,"default")],16,I)):(p(),u(l,c({key:1},e.$props,{custom:""}),{default:h((({isActive:t,href:n,navigate:a})=>[m("a",c(e.$attrs,{href:n,onClick:a,class:[t?"btn-blue":"btn-blue-inv","text-xl"]}),[d(e.$slots,"default")],16,_)])),_:3},16))};const C={name:"MypsWeb",components:{AppLink:M},props:{scrollWaiter:{type:Object,required:!0}},mounted(){this.scrollWaiter.flush()},methods:{setupWaiter(){this.scrollWaiter.add()},flushWaiter(){this.scrollWaiter.flush()},compress:e=>window.btoa(e),decompress:e=>window.atob(e)}},z={class:"flex flex-col min-h-screen"},O={class:"nav sticky top-0 z-10 p-2 bg-white border-b border-gray-400"},W=y(" Editor "),B=y(" About "),E=y(" Github ");C.render=function(e,t,n,a,o,r){const l=i("AppLink"),d=i("router-view");return p(),s("div",z,[m("div",O,[f(l,{to:{name:"Editor"},class:"mr-1"},{default:h((()=>[W])),_:1}),f(l,{to:{name:"About"},class:"mx-1"},{default:h((()=>[B])),_:1}),f(l,{to:"https://github.com/nilsso",class:"mx-1 disabled"},{default:h((()=>[E])),_:1})]),f(d,null,{default:h((({Component:e,route:t})=>[f(b,{mode:"out-in",name:t.meta.transitionName,onBeforeEnter:r.setupWaiter,onBeforeLeave:r.flushWaiter},{default:h((()=>[(p(),u(v,null,[(p(),u(g(e),{class:"flex-1"}))],1024))])),_:2},1032,["name","onBeforeEnter","onBeforeLeave"])])),_:1})])};const H={};const T={name:"Example",setup(e,t){const n=e=>{const t=e=>e.map((e=>e.children&&"string"!=typeof e.children?Array.isArray(e.children)?t(e.children):e.children.default?t(e.children.default()):void 0:e.children||"")).join("").trim();return e&&t(e())||""};return{lhs:n(t.slots.default),rhs:n(t.slots.rhs)}}},L={key:0,class:"example relative"},N={class:"grid grid-cols-2 auto-rows-auto divide-x divide-gray-600"},Y=m("svg",{xmlns:"http://www.w3.org/2000/svg",class:"h-6 w-6 hover:text-blue-500",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor"},[m("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"})],-1),D={key:1};T.render=function(e,t,n,a,o,r){const l=i("highlightjs"),d=i("router-link");return t[0]||(w(-1),t[0]=a.rhs?(p(),s("div",L,[m("div",N,[f(l,{code:a.lhs},null,8,["code"]),f(l,{code:a.rhs},null,8,["code"])]),f(d,{to:{name:"Editor",hash:"#"+this.$root.compress(this.lhs)},class:"absolute top-0 right-1/2 text-sm my-3e mx-2 text-gray-500 fill-current"},{default:h((()=>[Y])),_:1},8,["to"])])):(p(),s("div",D,[f(l,{class:"w-1/2 mx-auto",code:a.lhs},null,8,["code"])])),w(1),t[0])};const V=Object.fromEntries(["one","two","three","four","five","six"].map((e=>[e,{type:Boolean,default:!1}]))),R=x("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"}),$=x("svg",{xmlns:"http://www.w3.org/2000/svg",class:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor"},R);const F={name:"About",components:{Example:T,HeaderTag:{name:"BaseHeaderTag",render:function(){return x("h"+this.level,[this.$slots.default(),x("span",$)])},props:r({level:{type:null|Number,default:null},id:{type:String,default:""}},V),setup:e=>e.one?Object({level:1}):e.two?Object({level:2}):e.three?Object({level:3}):e.four?Object({level:4}):e.five?Object({level:5}):e.six?Object({level:6}):void 0}}},q={class:"w-1/2 mx-auto pt-4 pb-1/3h text-justify"},G=S("<h1>What is MYPS?</h1><p>MYPS is a custom DSL (domain specific language) I&#39;ve created that feels like Python but compiles into optimized Stationeers MIPS assembly code.</p><p>I decided to create MYPS from a desire to write more complicated programs for Stationeers without the necessary tedium of manually optimizing the MIPS assembly code. That being said I really like MIPS, and I wouldn&#39;t have the in game language be anything else, but the challenge of manually optimizing register allocations and cramming down into 128 lines started to become too much for me. I looked for other compiler/transpiler projects and found a few, but wasn&#39;t particularly satisfied. In particular, it seemed that no one had taken a swing at automatically optimizing register allocation; the one thing that I desired the most. So I decided to get down and learn some parser/lexer/compiler theory, and this project is the result.</p><p>Specifically, there are three parts to this project: </p><ol><li>a MIPS parser, lexer and optimizer</li><li>a parser and lexer for my custom language MYPS, and</li><li>a translator which maps the MYPS abstract syntax tree into a MIPS one, such that the MIPS optimizer can then do its work.</li></ol><p>All are written as libraries in the Rust language, which I can then compile into a Wasm binary for use in this Javascript Vue web application. All in all, it&#39;s been a lot to learn, I&#39;m very satisfied with the results, and yet there&#39;s plenty more to be improved.</p><h2>What this app does</h2><p>Within the editor tab, provide a source MYPS program and click compile (or hit shift-enter) to get back the translated MIPS source code for the MYPS input. Various translation optimizations are included at below the editor. These selections as well as the input and output source code are saved in the URL hash for sharing or re-opening later.</p><p><strong>As of writing there is not proper error management within the library itself, so the editor is entirely lacking in reporting what is going wrong. At the very least you can <em>see</em> that something went wrong, but an entire re-write of error handling within the MIPS AST, MYPS AST, and AST translator libraries is needed.</strong></p><hr><h1>Grammar Guide</h1><p>MYPS preserves much of the grammar of Python, but not everything can be the same when the purpose is to be translated into assembly as accurately as possible.</p><h2>Variables, lifetimes, and register allocation</h2><p>Variables are just like in Python; defined with any assignment statement: </p>",14),Q=m("template",null,[m("pre",null,"a = 1\n")],-1),K=m("p",null,[y("However register names like "),m("code",null,"r0"),y(" are forbidden. Why? Because registers are "),m("em",null,"automatically allocated"),y(" when the MYPS is compiled.")],-1),J=m("template",null,[m("pre",null,"move r0 = 1 # a = 1\n")],-1),U=m("p",null,"And not only is allocation automated but *optimized*. ",-1),X=m("template",null,[m("pre",null,"a = 1\nb = 2\nc = a + b\n")],-1),Z=m("pre",null,"move r0 = 1  # a = 1\nmove r1 = 2  # b = 2\nadd r0 r0 r1 # c = a + b\n",-1),ee=S("<p>What&#39;s happening here? On line 1 the allocator assigns the register <code>r0</code> for <code>a</code>, and on line 2 <code>r1</code> for <code>b</code>. Each variable has a <em>lifetime</em> which is as long as the last expression to use the variable. In this example, <code>a</code> and <code>b</code> need to live as long as line 3 where we have the expression <code>a + b</code>. The allocator is allowed to reuse the registers of any <em>dead</em> variables, and in this example it chooses <code>r0</code> for <code>c</code> since the lifetime of <code>a</code> ends on the same line as the new lifetime of <code>c</code>. What the allocator sees looks something like this graph:</p>",1),te=m("template",null,[m("pre",null,"0  r0 : 0 - 2\n1  r1 : | 1 2\n2  r2 : | | 2\n")],-1),ne=m("p",null,"One caveat is that a lifetime ends as soon as the variable is re-assigned. This also has the effect of reusing the same register, as we'll see below.",-1),ae=m("p",null,[y("Also note that the order in which variables are defined/initialized matters. For example, the following code fails to compile because "),m("code",null,"a"),y(" doesn't exist until after its use.")],-1),oe=m("template",null,[m("pre",null,"b = a / 2\na = 5\n")],-1),re=S('<p>(The main reason that this happens is because <code>a</code> has yet to be assigned a register by the allocator. For a method of circumventing this problem see the <a href="#">fixed variables</a> section.)</p><h2>Operator expressions</h2><p>Most <a href="#">Python operators</a> are implemented. Specifically the binary operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>, <code>and</code>, <code>or</code>, <code>xor</code>, <code>== </code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>,<code>&lt;</code> and <code>!=</code>; and the unary operators <code>-</code>, <code>!</code> are all preserved. Operator precedence is also the same as what you would expect.</p><p>Note that the binary <code>a^b</code> (raise <code>a</code> to the power <code>b</code>) isn&#39;t actually available as a single instruction in MIPS, and instead the translator inserts change of base instructions to compensate. Similarly, unary operators <code>-a</code> and <code>!a</code> become <code>0 - a</code> and <code>nor a a a</code> respectively.</p>',4),le=m("template",null,[m("pre",null,"a = 2\nb = -(a^4)\n")],-1),ie=m("pre",null,"move r0 2\nlog r0 r0\nmul r0 4 r0\nexp r0 r0\nsub r0 0 r0\n",-1),se=m("p",null,[y("(Also note parentheses must enclose unary operations that are part of other expressions like "),m("code",null,"(-a)*b"),y(", but like in the above example must enclose binary expressions that the unary operator precedes. The former is more a grammar bug, and likely something I'll eventually fix.)")],-1),de=m("p",null,[y("Additionally, MYPS supports the ternary operator by way of "),m("code",null,"select"),y(" in MIPS.")],-1),ce=m("template",null,[m("pre",null,"a = 1\nb = (a > 0) ? 2 : 3\n")],-1),ue=m("pre",null,"move r0 1\nsgt r0 r0 1\nselect r0 r0 2 3\n",-1),he=m("p",null,"(And as with unary operators, expression arguments need to be enclosed.) ",-1),pe=m("h2",null,"Compound expressions",-1),me=m("p",null,"Since MIPS can only do a single mathematical instruction per line, writing more complicated expressions can be an absolute chore, especially when it comes to not overwriting values you need somewhere later. However in MYPS we can write compound expressions and let the allocator do the tedious parts for us.",-1),fe=m("template",null,[m("pre",null,"a = 1\nb = 2\nc = 3\nb = (a + b) / c\n")],-1),be=m("pre",null,"move r0 1    # a = 1\nmove r1 2    # b = 2\nmove r2 3    # c = 3\nadd r0 r0 r1 # (a + b)\ndiv r1 r0 r2 # b = (a + b) / c\n",-1),ge=m("p",null,[y("By analyzing the lifetimes of each variable, the allocator can correctly expand the compound expression into single line instructions in a way that doesn't “clobber” any of the values that need to be alive further down. (Also note that "),m("code",null,"r1"),y(" is reused for "),m("code",null,"b"),y(" despite "),m("code",null,"r0"),y(" being available.) ")],-1),ve=m("h2",null,"Defines",-1),ye=m("p",null,[y("Like in MIPS, we can define constant values using the "),m("code",null,"def"),y(" prefix, with the added bonus that defines in MYPS can be constant valued expressions that the compiler will reduce to a value. Additionally, the define line itself will be removed and all occurrences of if replaced accordingly, so as to save some lines.")],-1),we=m("template",null,[m("pre",null,"def V = 1500 / 3\na = 600\nif a > V:\n    yield()\n")],-1),xe=m("pre",null,"move r0 600\nbrle r0 500 2\nyield\n",-1),Se=m("p",null,[m("strong",null,[y("(Note that definitions "),m("em",null,"currently"),y(" only support expressions of literal numbers, but eventually I'll fix this to allow definitions that are expressions of other definitions.) ")])],-1),ke=m("h2",null,"Working with devices",-1),Pe=m("p",null,[y("Devices in MYPS can be used referenced by "),m("code",null,"d?"),y(", just like in MIPS, but also aliased in an identical grammar to assigning to a variable.")],-1),je=m("template",null,[m("pre",null,"sensor = d0\n")],-1),Ae=m("pre",null,"alias sensor d0",-1),Me=m("p",null,[y("Devices can even be referenced indirectly with the grammar "),m("code",null,"d(x)"),y(", where "),m("code",null,"x"),y(" can be a literal, a define, a variable, or even an expression.")],-1),Ie=m("template",null,[m("pre",null,"for i in (0:3):\n    d(i).On = d(i+3).Setting\n")],-1),_e=m("pre",null,"move r0 0\nbrge r0 3 6\nadd r1 r0 3\nl r1 dr1 Setting\ns dr0 On r1\nadd r0 r0 1\njr -5\n",-1),Ce=S('<p>(See the <a href="#">blocks and control flow</a> section for the for-loop grammar.) </p><p>Reading logic parameters has the grammar <code>d?.Parameter</code>, slot parameters have <code>d?[Slot].Parameter</code> and reagent parameters have <code>d?{Parameter}.Reagent</code> (chosen to match the order of parameters of <code>l</code>, <code>ls</code> and <code>lr</code>). Writing to a logic parameter works just like assigning to a variable.</p>',2),ze=m("template",null,[m("pre",null,"a = d0.Setting          # Setting logic parameter\nb = d0[0].Quantity      # Quantity slot parameter from slot 0\nc = d0{Required}.Copper # Required count of the Copper reagent\nd0.On = a + b + c\n")],-1),Oe=m("pre",null,"l r0 d0 Setting\nls r1 d0 0 Quantity\nlr r2 d0 1 Copper\nadd r0 r0 r1\nadd r0 r0 r2\ns d0 On r0\n",-1),We=S("<p>Secondly, batch reading and writing has the grammar <code>Hash.all.Parameter</code> for batch writing, and <code>Hash.all.Parameter.Mode</code> for reading (where <code>Mode</code> is one of <code>Average</code>/<code>Avg</code>, <code>Sum</code>, <code>Min</code> or <code>Max</code>, or a corresponding number values). The hash can be provided as a literal, as a definition, or even as a variable.</p>",1),Be=m("template",null,[m("pre",null,"def ObjectA = 123\nobjectB = 456\nObjectA.all.Setting = objectB.all.Setting.Average + 789.all.Setting.Sum\n")],-1),Ee=m("pre",null,"move r0 456\nlb r0 r0 Setting 0\nlb r1 789 Setting 1\nadd r0 r0 r1\nsb 123 Setting r0\n",-1),He=m("p",null,[y("And as this last example demonstrates, any of the reading grammars can be use directly within expressions. For a "),m("em",null,"full"),y(" example, here is a complete two-axis sun tracking solar panel program using these grammars:")],-1),Te=m("template",null,[m("pre",null,"sensor = d0\n# provides a multiple of 90 offset to the horizontal\n# just to make setting up easier\noffsetDial = d1\ndef Normal     = -2045627372\ndef NormalDual = -539224550\ndef Heavy      = -934345724\ndef HeavyDual  = -1545574413\nloop: # loop\n    yield()\n    h = sensor.Horizontal + (offsetDial.Setting * 90)\n    Normal    .all.Horizontal = h\n    NormalDual.all.Horizontal = h\n    Heavy     .all.Horizontal = h\n    HeavyDual .all.Horizontal = h\n    v = (75 - sensor.Vertical) / 1.5\n    Normal    .all.Vertical   = v\n    NormalDual.all.Vertical   = v\n    Heavy     .all.Vertical   = v\n    HeavyDual .all.Vertical   = v\n")],-1),Le=m("pre",null,"alias sensor d0\nalias offsetDial d1\nyield\nl r0 d0 Horizontal\nl r1 d1 Setting\nmul r1 r1 90\nadd r0 r0 r1\nsb -2045627372 Horizontal r0\nsb -539224550 Horizontal r0\nsb -934345724 Horizontal r0\nsb -1545574413 Horizontal r0\nl r0 d0 Vertical\nsub r0 75 r0\ndiv r0 r0 1.5\nsb -2045627372 Vertical r0\nsb -539224550 Vertical r0\nsb -934345724 Vertical r0\nsb -1545574413 Vertical r0\njr -16\n",-1),Ne=S('<h2>Compound assignment</h2><p>A grammar feature common to many languages, <a href="">Python included</a>, is compound assignment. Specifically the operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code> and <code>%=</code> are preserved.</p>',2),Ye=m("template",null,[m("pre",null,"a = 1\na *= a + 1\n")],-1),De=m("pre",null,"move r0 1    # a = 1\nadd r1 r0 1  # a + 1\nmul r0 r0 r1 # a *= a + 1 <-> a = a * (a + 1)\n",-1),Ve=S("<h2>Functions</h2><p>Functions cannot be defined in MYPS like they can in Python; this is too daunting of a task when it comes to considering how any particular function definition should be translated into assembly. However the grammar of function calls is preserved for many MIPS function-like instructions; any of which can be used in expressions.</p><table><tr><th>Function</th> <th>Description</th></tr><tr><td><code>abs(a)</code></td><td>Absolute value of <code>a</code></td></tr><tr><td><code>acos(a)</code></td><td>Inverse cosine of <code>a</code></td></tr><tr><td><code>asin(a)</code></td><td>Inverse sine of <code>a</code> if 0 ≤ <code>a</code> ≤ 1, else 0</td></tr><tr><td><code>atan(a)</code></td><td>Inverse tangent of <code>a</code> if 0 ≤ <code>a</code> ≤ 1, else 0</td></tr><tr><td><code>ceil(a)</code></td><td>Nearest integer ≥ <code>a</code> if 0 ≤ <code>a</code> ≤ 1, else 0</td></tr><tr><td><code>cos(a)</code></td><td>Cosine of <code>a</code></td></tr><tr><td><code>dec(a)</code></td><td>Decimal part of <code>a</code> (implemented as <code>a-trunc(a)</code>)</td></tr><tr><td><code>exp(a)</code></td><td>Exponential function of <code>a</code></td></tr><tr><td><code>floor(a)</code></td><td>Nearest integer ≤ <code>a</code></td></tr><tr><td><code>log(a,b)</code></td><td>Logarithm of <code>a</code> to base <code>b</code> (implemented as <code>ln(a)/ln(b)</code>)</td></tr><tr><td><code>ln(a)</code></td><td>Logarithm of <code>a</code> to base *e*</td></tr><tr><td><code>max(a,b)</code></td><td>Maximum of <code>a</code> and <code>b</code></td></tr><tr><td><code>min(a,b)</code></td><td>Minimum of <code>a</code> and <code>b</code></td></tr><tr><td><code>rand()</code></td><td>Random value in range (0,1)</td></tr><tr><td><code>round(a)</code></td><td>Nearest integer to <code>a</code></td></tr><tr><td><code>sin(a)</code></td><td>Sine of <code>a</code></td></tr><tr><td><code>sqrt(a)</code></td><td>Square-root of <code>a</code></td></tr><tr><td><code>tan(a)</code></td><td>Tangent of <code>a</code></td></tr><tr><td><code>trunc(a)</code></td><td>Integer part of <code>a</code></td></tr><tr><td><code>peek()</code></td><td>Return stack value <code>sp-1</code></td></tr><tr><td><code>pop()</code></td><td>Return stack value <code>sp-1</code>, then decrement <code>sp</code></td></tr><tr><td><code>dns(d)</code></td><td>1 if device <code>d</code> not set, else 0</td></tr><tr><td><code>dse(d)</code></td><td>1 if device <code>d</code> set, else 0</td></tr></table><h2>Raw MIPS</h2><p>There are plenty of things that MIPS can do that aren&#39;t possible using only Python grammar, such as arbitrary line jumps. To account for this, *any* MIPS instruction can be expressed like a Python function, with the caveat that each argument must be valid MIPS; so no compound expressions or function calls, but variables are fine.</p>",5),Re=m("template",null,[m("pre",null,"a = 0\nb = 1\nj(10) # jump to line 10\nbltal(a, b, 20) # branch to line 20, storing next line in ra, if a < b\n")],-1),$e=m("pre",null,"move r0 0\nmove r1 1\nj 10\nbltal r0 r1 20\n",-1),Fe=m("h2",null,"Blocks and control flow",-1),qe=m("p",null,[y("Most of Python's blocks and control flow grammar is preserved in MYPS, in particular the use of indents to denote a block. "),m("strong",null,[y("(For now and by default these indents "),m("em",null,"must"),y(" be four spaces but are lexed exactly as they are in Python; I'll change this eventually to support configurable indent sizes.)")])],-1),Ge=m("p",null,[y("We have the "),m("strong",null,[y("infinite "),m("code",null,"loop")])],-1),Qe=m("template",null,[m("pre",null,"loop:\n    yield()\n")],-1),Ke=m("pre",null,"yield\njr -1\n",-1),Je=m("p",null,[m("strong",null,[y("the "),m("code",null,"tag")]),y(", the MYPS equivalent to line tags in MIPS")],-1),Ue=m("template",null,[m("pre",null,"a = 0\ntag A:\n    a *= 2\nj(A)\n")],-1),Xe=m("pre",null,"move r0 0\nmul r0 r0 2\nj 1\n",-1),Ze=m("p",null,[m("strong",null,[m("code",null,"if-elif-else"),y(" chains")])],-1),et=m("template",null,[m("pre",null,"a = 0\nv = d0.Setting\nif v == 0:\n    a = 1\nelif v == 1:\n    a = 2\nelse:\n    a = 3\n")],-1),tt=m("pre",null,"move r0 0\nl r1 d0 Setting\nbrnez r1 3\nmove r0 1\nj 9\nbrne r1 1 3\nmove r0 2\nj 9\nmove r0 3\n",-1),nt=m("strong",null,[m("code",null,"while"),y(" loops")],-1),at=m("template",null,[m("pre",null,"i = 10\nwhile i > 10:\n    i -= 1\n")],-1),ot=m("pre",null,"move r0 10\nbrle r0 10 3\nsub r0 r0 1\njr -2\n",-1),rt=m("p",null,[m("strong",null,[y("numerical "),m("code",null,"for"),y(" loops")]),y(" (granted with some slightly modified grammar)")],-1),lt=m("template",null,[m("pre",null,"a = 1\nfor i in (0:10:1): # or simply (0:10)\n    a *= 2\n")],-1),it=m("pre",null,"move r0 1    # a = 1\nmove r1 0    # i = 0\nbrge r1 10 4 # while i < 10\nmul r0 r0 2\nadd r1 r1 1  # i += 1\njr -3\n",-1),st=m("p",null,[y("Note that for the range "),m("code",null,"(s:e[:step])"),y(", any part can itself be an expression.")],-1),dt=m("template",null,[m("pre",null,"a = 1\nfor i in (a:a*5:a):\n    a *= 2\n")],-1),ct=m("pre",null,"move r0 1\nmul r2 r0 5\nbrge r1 r2 4\nmul r0 r0 2\nadd r1 r1 r0\njr -3\n",-1),ut=m("h2",null,"Fixed variables",-1),ht=m("p",null,"The register allocator is not perfect. Since MYPS can also translate arbitrary line jumps like in MIPS, we have no way to linearly analyze the lifetimes of variables that are needed on a line prior to their definition (at least not without some much deeper algorithms). Consider this extremely contrived example:",-1),pt=m("template",null,[m("pre",null,"j(AssignACalcB)\ntag CalcC:\n    c = a * 2\ntag AssignACalcB:\n    a = 1\n    b = 2\nj(CalcC)\n")],-1),mt=m("p",null,[y("But this doesn't compile, because linear analysis doesn't show that, because of the jumps, "),m("code",null,"a"),y(" will actually be alive by the time of the "),m("code",null,"c = a * 2"),y(" statement. We might first try to fix this by initializing "),m("code",null,"a"),y(".")],-1),ft=m("template",null,[m("pre",null,"a = 0\nj(AssignACalcB)\ntag CalcC:\n    c = a * 2\ntag AssignACalcB:\n    a = 1\n    b = 2\nj(CalcC)\n")],-1),bt=m("pre",null,"move r0 0\nj 3\nmul r0 r0 2\nmove r0 1\nmove r0 2\nj 2\n",-1),gt=S("<p>Which compiles, but notice that the register <code>r0</code> which was allocated for <code>a</code> has been re-used for the allocation of <code>b</code>, clobbering whatever value was in <code>a</code> that needed to be used for the <code>c</code> statement. To <em>fix</em> this, we can either prefix the <code>a</code> initialization with the keyword <code>fix</code> or by replacing the initialization with a <em>fix declaration</em>.</p>",1),vt={class:"example-group"},yt=m("template",null,[m("pre",null,"fix a = 0 # fixed initialization\nj(AssignACalcB)\ntag CalcC:\n    c = a * 2\ntag AssignACalcB:\n    a = 1\n    b = 2\nj(CalcC)\n")],-1),wt=m("pre",null,"move r0 0\nj 3\nmul r1 r0 2\nmove r0 1\nmove r1 2\nj 2\n",-1),xt=m("template",null,[m("pre",null,"fix a # fix declaration\nj(AssignACalcB)\ntag CalcC:\n    c = a * 2\ntag AssignACalcB:\n    a = 1\n    b = 2\nj(CalcC)\n")],-1),St=m("pre",null,"j 2\nmul r1 r0 2\nmove r0 1\nmove r1 2\nj 1\n",-1),kt=m("p",null,[y("This tells the allocator that the lifetime of "),m("code",null,"a"),y(" should be global (or more precisely as long as the block it is in; see the next section for specifics on this) and now have that the register "),m("code",null,"r0"),y(" allocated for "),m("code",null,"a"),y(" is fixed and wont be re-used later.")],-1),Pt=m("p",null,'The most common use for fixed variables seems to be for variables whose "old" values need to persist throughout a loop, such as an error term in a PID controller.',-1),jt=m("h2",null,"Lifetime scoping",-1),At=m("p",null,"Finally, blocks are used by MYPS to help the allocator determine better fixed lifetimes for the program as a whole. If a variable is fixed within a block, then its lifetime isn't global, but as long as the containing block. This way its possible to fix a variable within a block, but then have the allocator re-use the variable's allocated register anywhere outside of and below the block.",-1),Mt=m("hr",null,null,-1);F.render=function(e,t,n,a,o,r){const l=i("Example");return p(),s("div",q,[G,f(l,null,{default:h((()=>[Q])),_:1}),K,f(l,null,{default:h((()=>[J])),_:1}),U,f(l,null,{rhs:h((()=>[Z])),default:h((()=>[X])),_:1}),ee,f(l,null,{default:h((()=>[te])),_:1}),ne,ae,f(l,null,{default:h((()=>[oe])),_:1}),re,f(l,null,{rhs:h((()=>[ie])),default:h((()=>[le])),_:1}),se,de,f(l,null,{rhs:h((()=>[ue])),default:h((()=>[ce])),_:1}),he,pe,me,f(l,null,{rhs:h((()=>[be])),default:h((()=>[fe])),_:1}),ge,ve,ye,f(l,null,{rhs:h((()=>[xe])),default:h((()=>[we])),_:1}),Se,ke,Pe,f(l,null,{rhs:h((()=>[Ae])),default:h((()=>[je])),_:1}),Me,f(l,null,{rhs:h((()=>[_e])),default:h((()=>[Ie])),_:1}),Ce,f(l,null,{rhs:h((()=>[Oe])),default:h((()=>[ze])),_:1}),We,f(l,null,{rhs:h((()=>[Ee])),default:h((()=>[Be])),_:1}),He,f(l,null,{rhs:h((()=>[Le])),default:h((()=>[Te])),_:1}),Ne,f(l,null,{rhs:h((()=>[De])),default:h((()=>[Ye])),_:1}),Ve,f(l,null,{rhs:h((()=>[$e])),default:h((()=>[Re])),_:1}),Fe,qe,Ge,f(l,null,{rhs:h((()=>[Ke])),default:h((()=>[Qe])),_:1}),Je,f(l,null,{rhs:h((()=>[Xe])),default:h((()=>[Ue])),_:1}),Ze,f(l,null,{rhs:h((()=>[tt])),default:h((()=>[et])),_:1}),nt,f(l,null,{rhs:h((()=>[ot])),default:h((()=>[at])),_:1}),rt,f(l,null,{rhs:h((()=>[it])),default:h((()=>[lt])),_:1}),st,f(l,null,{rhs:h((()=>[ct])),default:h((()=>[dt])),_:1}),ut,ht,f(l,null,{default:h((()=>[pt])),_:1}),mt,f(l,null,{rhs:h((()=>[bt])),default:h((()=>[ft])),_:1}),gt,m("div",vt,[f(l,null,{rhs:h((()=>[wt])),default:h((()=>[yt])),_:1}),f(l,null,{rhs:h((()=>[St])),default:h((()=>[xt])),_:1})]),kt,Pt,jt,At,Mt])};const It=[{path:"/apps/myps2/",name:"Editor",component:()=>{return e=()=>import("./Editor.40629357.js"),(t=["assets/Editor.40629357.js","assets/Editor.9e432da9.css","assets/vendor.c3ad2312.js"])&&0!==t.length?Promise.all(t.map((e=>{if((e=`/apps/myps2/${e}`)in H)return;H[e]=!0;const t=e.endsWith(".css"),n=t?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${e}"]${n}`))return;const a=document.createElement("link");return a.rel=t?"stylesheet":"modulepreload",t||(a.as="script",a.crossOrigin=""),a.href=e,document.head.appendChild(a),t?new Promise(((e,t)=>{a.addEventListener("load",e),a.addEventListener("error",t)})):void 0}))).then((()=>e())):e();var e,t},meta:{transitionName:"fade"}},{path:"/apps/myps2/about",name:"About",component:F,meta:{transitionName:"fade"}},{path:"/apps/myps2/:pathMatch(.*)*",redirect:{name:"Editor"}}];const _t=function(){let e,t;const n={promise:t,add:function(){t=new Promise((t=>{e=t}))},flush:function(){e&&e(),e=void 0,t=void 0}};return Object.defineProperty(n,"promise",{get:()=>t}),n}(),Ct=(zt=_t,k({history:P(),routes:It,scrollBehavior:async(e,t,n)=>(await zt.promise,{top:0,behavior:"auto"})}));var zt;const Ot=j(C,{scrollWaiter:_t}).use(A).use(Ct);_t.add(),Ct.isReady().then((()=>window.vm=Ot.mount("#app")));
